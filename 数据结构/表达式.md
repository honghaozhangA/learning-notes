## 表达式

#### 前缀表达式

从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 和 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果

例如: (3+4)×5-6 对应的前缀表达式就是 **- × + 3 4 5** **6 ,** **针对前缀表达式求值步骤**如下:

1. 从**右至左扫描**，将6、5、4、3压入堆栈
2. 遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素），计算出3+4的值，得7，再将7入栈
3. 接下来是×运算符，因此弹出7和5，计算出7×5=35，将35入栈
4. 最后是-运算符，计算出35-6的值，即29，由此得出最终结果

****

#### 中缀表达式

中缀表达式就是**常见的运算表达式**，如(3+4)×5-6

中缀表达式的求值是我们人最熟悉的，但是对计算机来说却不好操作(前面我们讲的案例就能看的这个问题)，因此，在计算结果时，往往会将中缀表达式转成其它表达式来操作(一般转成后缀表达式.)

****

#### 后缀表达式

后缀表达式又称**逆波兰表达式**,与前缀表达式相似，只是运算符位于操作数之后

中举例说明： (3+4)×5-6 对应的后缀表达式就是 **3** **4 + 5 × 6** **–**

| 正常的表达式 | 逆波兰表达式  |
| ------------ | ------------- |
| a+b          | a b +         |
| a+(b-c)      | a b c - +     |
| a+(b-c)*d    | a b c – d * + |
| a+d*(b-c)    | a d b c - * + |
| a=1+3        | a 1 3 + =     |

##### 计算

从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果

例如: (3+4)×5-6 对应的后缀表达式就是 **3 4 + 5 × 6 -** **,** 针对后缀表达式求值步骤如下:

1. 从左至右扫描，将3和4压入堆栈；
2. 遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；
3. 将5入栈；
4. 接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；
5. 将6入栈；
6. 最后是-运算符，计算出35-6的值，即29，由此得出最终结果

****

#### 中缀表达式转后缀表达式

大家看到，后缀表达式适合计算式进行运算，但是人却不太容易写出来，尤其是表达式很长的情况下，因此在开发中，我们需要将 中缀表达式**转成**后缀表达式。

1. 初始化两个栈：运算符栈s1和储存中间结果的栈s2；
2. 从左至右扫描中缀表达式；
3. 遇到操作数时，将其压s2；
4. 遇到运算符时，比较其与s1栈顶运算符的优先级：

- ​	如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；
- ​	否则，若优先级比栈顶运算符的高，也将运算符压入s1；
- ​	否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符相比较；

5. 遇到括号时：

- ​	如果是左括号“(”，则直接压入s1
- ​	如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃

6. 重复步骤2至5，直到表达式的最右边

7. 将s1中剩余的运算符依次弹出并压入s2

8. 依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式

| 扫描到的元素 | s2(栈底->栈顶)         | s1 (栈底->栈顶) | 说明                               |
| ------------ | ---------------------- | --------------- | ---------------------------------- |
| 1            | 1                      | 空              | 数字，直接入栈                     |
| +            | 1                      | +               | s1为空，运算符直接入栈             |
| (            | 1                      | + (             | 左括号，直接入栈                   |
| (            | 1                      | + ( (           | 同上                               |
| 2            | 1 2                    | + ( (           | 数字                               |
| +            | 1 2                    | + ( ( +         | s1栈顶为左括号，运算符直接入栈     |
| 3            | 1 2 3                  | + ( ( +         | 数字                               |
| )            | 1 2 3 +                | + (             | 右括号，弹出运算符直至遇到左括号   |
| ×            | 1 2 3 +                | + ( ×           | s1栈顶为左括号，运算符直接入栈     |
| 4            | 1 2 3 + 4              | + ( ×           | 数字                               |
| )            | 1 2 3 + 4 ×            | +               | 右括号，弹出运算符直至遇到左括号   |
| -            | 1 2 3 + 4 × +          | -               | -与+优先级相同，因此弹出+，再压入- |
| 5            | 1 2 3 + 4 × + 5        | -               | 数字                               |
| 到达最右端   | **1  2 3 + 4 × + 5 -** | 空              | s1中剩余的运算符                   |