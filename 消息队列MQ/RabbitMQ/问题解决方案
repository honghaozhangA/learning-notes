1. 消息堆积
    一般是由于网络不稳定的原因
    当消息生产的速度长时间，远远大于消费的速度时。就会造成消息堆积。

    消息堆积的影响
        可能导致新消息无法进入队列
        可能导致旧消息无法丢失
        消息等待消费的时间过长，超出了业务容忍范围
    产生堆积的情况
        生产者突然大量发布消息
        消费者消费失败
        消费者出现性能瓶颈
        消费者挂掉
    解决办法
        排查消费者的消费性能瓶颈
        增加消费者的多线程处理
        部署增加多个消费者

2. 消息丢失
    MQ服务器宕机或者重启会出现这种情况
    消息丢失的场景主要分为：消息在生产者丢失，消息在RabbitMQ丢失，消息在消费者丢失。

    消息在生产者丢失
        采用RabbitMQ 发送方消息确认机制，当消息成功被MQ接收到时，会给生产者发送一个确认消息，表示接收成功。RabbitMQ 发送方消息确认模式有以下三种：普通确认模式，批量确认模式，异步监听确认模式。spring整合RabbitMQ后只使用了异步监听确认模式。
    消息在RabbitMQ丢失
        持久化交换机，队列，消息，确保MQ服务器重启时依然能从磁盘恢复对应的交换机，队列和消息。
        spring整合后默认开启了交换机，队列，消息的持久化，所以不修改任何设置就可以保证消息不在RabbitMQ丢失。
    消息在消费者丢失
        设置为手动回复MQ服务器，当消费者出现异常或者服务宕机时，MQ服务器不会删除该消息，而是会把消息重发给绑定该队列的消费者，如果该队列只绑定了一个消费者，那么该消息会一直保存在MQ服务器，直到消息者能正常消费为止。

3. 重复消费
    为了防止消息在消费者端丢失，会采用手动回复MQ的方式来解决，同时也引出了一个问题，消费者处理消息成功，手动回复MQ时由于网络不稳定，连接断开，导致MQ没有收到消费者回复的消息，那么该条消息还会保存在MQ的消息队列，由于MQ的消息重发机制，会重新把该条消息发给和该队列绑定的消息者处理，这样就会导致消息重复消费

    如果消费消息的业务是幂等性操作（同一个操作执行多次，结果不变）就算重复消费也没问题
    如果不支持幂等性操作，如：下单，减库存，扣款等，那么可以在消费者端每次消费成功后将该条消息id保存到数据库，每次消费前查询该消息id，如果该条消息id已经存在那么表示已经消费过就不再消费否则就消费。本方案采用redis存储消息id，因为redis是单线程的，并且性能也非常好，提供了很多原子性的命令，本方案使用setnx命令存储消息id

4. 顺序消费消息
    同一组的任务会被分配到同一个队列里，每个队列只能有一个worker来消费，独占
